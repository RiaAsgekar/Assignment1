WEBVTT

1
00:00:05.180 --> 00:00:10.790
Ria Asgekar: Hello! My name is Ria. I'm here with my teammates, Avantika and Jeevan.

2
00:00:11.050 --> 00:00:23.420
Ria Asgekar: In this assignment we are performing expression evaluation, using stack. We'll be evaluating various mathematical expressions, using infix and postfix. And then we will be comparing the 2.

3
00:00:23.580 --> 00:00:31.150
Ria Asgekar: We'll be using 3 algorithms here and the first one we'll be evaluating annex expression. Using 2 stacks

4
00:00:31.410 --> 00:00:39.169
Ria Asgekar: in the next 2. We'll be first converting the infix expression to postfix, and then we'll evaluate the postfix expression.

5
00:00:39.550 --> 00:00:48.889
Ria Asgekar: We've used stark because it works well with the nature of mathematical expressions, specifically the requirement to maintain the order of operations.

6
00:00:48.970 --> 00:00:52.710
Ria Asgekar: So the last and first out, nature really, helps you.

7
00:00:53.250 --> 00:00:54.240
Ria Asgekar: R,

8
00:00:55.455 --> 00:00:58.545
Ria Asgekar: okay, in the stack class.

9
00:00:59.740 --> 00:01:04.719
Ria Asgekar: we are primarily using 3 push pop and peak operations.

10
00:01:04.819 --> 00:01:11.410
Ria Asgekar: The push operation adds, the current value to the top of the stack.

11
00:01:11.570 --> 00:01:20.040
Ria Asgekar: The pop removes it from the top of the stack, and the peak operation is to find out which element is at the top.

12
00:01:20.642 --> 00:01:28.950
Ria Asgekar: We've also defined 2 others is empty to check. If there are any elements of this, if there are no elements in this tab

13
00:01:28.980 --> 00:01:32.870
Ria Asgekar: and size, just to find out how many elements there are.

14
00:01:34.886 --> 00:01:37.940
Ria Asgekar: Next to G, one will take over.

15
00:01:40.060 --> 00:01:43.919
Jeevan Raju: My name is Steven. And let's dive deeper into the program.

16
00:01:43.930 --> 00:01:49.140
Jeevan Raju: So first let's understand, infix to postfix expression conversion, using a stack

17
00:01:50.090 --> 00:01:55.330
Jeevan Raju: so, to convert an infix expression to postfix we use a stag to store operators.

18
00:01:55.340 --> 00:01:58.599
Jeevan Raju: We scan the infix expression from left to right.

19
00:01:58.900 --> 00:02:03.170
Jeevan Raju: If an operand is encountered, it is added directly to the output.

20
00:02:03.420 --> 00:02:09.740
Jeevan Raju: If an operator is encountered, we first compare its precedence with the operator at the top of this tab.

21
00:02:10.130 --> 00:02:14.709
Jeevan Raju: If the precedence of the current operator is higher, we push it onto the stack.

22
00:02:15.050 --> 00:02:26.159
Jeevan Raju: If it is lower or equal, we pop operators from the stack and add them to the output until we find an operator with a lower precedence or the stack becomes empty.

23
00:02:26.400 --> 00:02:29.629
Jeevan Raju: Finally, we push the current operator onto the stack.

24
00:02:30.230 --> 00:02:33.839
Jeevan Raju: So, Avantika. Can you run this and show the

25
00:02:40.140 --> 00:02:46.599
Jeevan Raju: so? This is a sample output of infix expression converted into a postfix expression

26
00:02:47.330 --> 00:02:51.740
Jeevan Raju: later. Now let's move on to postfix expression evaluation

27
00:02:52.050 --> 00:02:54.310
Jeevan Raju: in postfix evaluation.

28
00:02:54.380 --> 00:02:57.540
Jeevan Raju: We scan the expression from left to right

29
00:02:57.570 --> 00:03:03.369
Jeevan Raju: as a single scan. When an operand is encountered we push it onto the stack.

30
00:03:03.510 --> 00:03:09.050
Jeevan Raju: When an operator is encountered, we pop the required number of operands from the stack.

31
00:03:09.200 --> 00:03:13.940
Jeevan Raju: perform the required operation, and push the result back onto the stack.

32
00:03:14.270 --> 00:03:20.770
Jeevan Raju: We continue this process until we have evaluated the entire expression resulting in the final answer.

33
00:03:24.630 --> 00:03:27.619
Jeevan Raju: So running this part of the program

34
00:03:28.170 --> 00:03:31.269
Jeevan Raju: gives us a single output at the end.

35
00:03:32.030 --> 00:03:36.359
Jeevan Raju: Lastly, let's discuss infix expression. Evaluation

36
00:03:37.557 --> 00:03:42.029
Jeevan Raju: this part of the program mainly uses 2 stacks.

37
00:03:43.020 --> 00:03:48.226
Jeevan Raju: There's no conversion into a post fix expression, and this is done

38
00:03:49.290 --> 00:03:50.840
Jeevan Raju: as a benchmark

39
00:03:51.190 --> 00:03:54.999
Jeevan Raju: to compare performance during expression evaluation.

40
00:03:55.490 --> 00:03:58.050
Jeevan Raju: Thank you. Avantika will take over.

41
00:04:03.920 --> 00:04:10.039
Avantika Sivakumar: So when we run the infix evaluation code, again, we get the same result.

42
00:04:10.080 --> 00:04:13.289
Avantika Sivakumar: But we use 2 stacks, and we can see how

43
00:04:13.970 --> 00:04:16.269
Avantika Sivakumar: The result is calculated.

44
00:04:16.500 --> 00:04:22.810
Avantika Sivakumar: So coming to the experiments and results, part of the assignment in the test class, we've defined

45
00:04:23.010 --> 00:04:29.969
Avantika Sivakumar: many test cases with varied complexities that is, having different numbers of operators and operands.

46
00:04:30.030 --> 00:04:38.850
Avantika Sivakumar: So for each of these infix expressions, we run the 3 algorithms, and we compare the timings for evaluating the infix expression directly.

47
00:04:39.010 --> 00:04:40.163
Avantika Sivakumar: and for

48
00:04:40.770 --> 00:04:46.020
Avantika Sivakumar: evaluating the infix expression after first converting it to a postfix expression.

49
00:04:46.130 --> 00:04:51.125
Avantika Sivakumar: So we've also handled edge cases like invalid expressions, for example,

50
00:04:51.640 --> 00:04:55.550
Avantika Sivakumar: with unbalanced parentheses like this example here.

51
00:04:55.650 --> 00:05:00.980
Avantika Sivakumar: or with arithmetic errors like they divide by 0 error

52
00:05:01.140 --> 00:05:03.720
Avantika Sivakumar: or with errors where

53
00:05:04.130 --> 00:05:08.720
Avantika Sivakumar: the expression does not have only digits like this one.

54
00:05:09.920 --> 00:05:11.700
Avantika Sivakumar: So we can run this.

55
00:05:11.830 --> 00:05:12.860
Avantika Sivakumar: And

56
00:05:13.380 --> 00:05:25.820
Avantika Sivakumar: yeah, as we can see, when there is a letter, it says that there's an invalid in fixed expression. And if there's a 0 divide by 0 error, that is also mentioned.

57
00:05:26.790 --> 00:05:34.539
Avantika Sivakumar: So as we can see from the output. The test cases that are longer or basically have more number of operators in operands

58
00:05:34.590 --> 00:05:39.979
Avantika Sivakumar: will take longer time than those that have fewer number of operators and operands.

59
00:05:40.220 --> 00:05:42.310
Avantika Sivakumar: And we can also see that

60
00:05:42.540 --> 00:05:57.839
Avantika Sivakumar: T 2 is generally much shorter than t one. Basically, it takes less time to convert the I mean sorry to evaluate the infix expression directly, using 2 stats when compared to

61
00:05:58.320 --> 00:06:02.110
Avantika Sivakumar: converting it to a post-fix expression and then evaluating it.

62
00:06:02.310 --> 00:06:08.860
Avantika Sivakumar: The first test case is always longer irrespective of its complexity, and this is because the

63
00:06:08.900 --> 00:06:16.430
Avantika Sivakumar: jet compiler takes extra time to optimize the course. So the first test case is just used to warm up the loop.

64
00:06:16.570 --> 00:06:20.559
Avantika Sivakumar: but we do not consider it for further analysis of the results.

65
00:06:21.320 --> 00:06:22.420
Avantika Sivakumar: Thank you.

